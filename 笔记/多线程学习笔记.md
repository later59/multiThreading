# 			     多线程学习笔记

## 一、基本概念

### 1、并发

​	同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替的换入或者换出内存，这些线程是同时 ”存在“ 的，每个线程都处于执行过程中的某个状态。如果运行在多核处理器上，此时，程序中的每个线程都将都将分配到一个处理器核上，因此可以同时运行。

多个线程操作相同的资源，保证线程安全，合理使用资源

### 2、高并发

​	高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指：通过保证系统能够**同时并行处理**很多请求

服务能同时处理很多请求，提高程序性能



## 二、并发编程的基础

### 1、CPU多级缓存

Main Memory：主存

Bus：系统总线

Cache：高速缓存

CPU Core：CPU 核心

L1 Cache：一级或者二级缓存

![](.\images\1.jpg)

### 2、为什么需要CPU cache

CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题。（存储速度：CPU > cache > memory）

### 3、CPU cache 有什么意义

1）时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。

2）空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问。

### 4、CPU 多级缓存 - 缓存一致性（MESI）

1）用于保证多个CPU cache之间缓存共享数据的一致



| 状态                | 描述                                                         | 监听任务                                                     |
| :------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| M 被修改 (Modified) | 该缓存行只被缓存在该CPU的缓存中，数据是被修改过的，和主内存中的数据不一致，该数据会在未来的某个时间点写回到主存中，数据被写回主存之后，状态变成E | 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 |
|                     |                                                              |                                                              |
|                     |                                                              |                                                              |
| E 独享(Exclusive)   | 缓存行只被缓存在该CPU的缓存中，是未被修改过的，与主存 中的数据一致。如果被其他CPU读取就会变成S状态 | 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 |
|                     |                                                              |                                                              |
| S 共享 (Shared)     | 该缓存行中的数据被多个CPU进行缓存，并且数据与主存中的数据一致，如果某个CPU更改了数据，其他CPU中该缓存行就会变成I状态 | 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 |
|                     |                                                              |                                                              |
|                     |                                                              |                                                              |
| I 无效 (Invalid)    | 该Cache line无效。                                           | 无                                                           |



local read：读本地缓存中的数据

local write：将数据写到本地缓存中

remote read：将主存中的数据读取到

remote write：将数据写回到主存中



![](./images/2.jpg)



### 5、CPU乱序执行优化

​	1）什么是乱序执行优化？

​		处理器为提高运算速度而做出违背代码原有顺序的优化



### 6、Java内存模型（Java Memory Model，JMM）

​	规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值以及在必须时如何同步的访问共享变量

堆（Heap）：

优点：可以动态分配内存大小，生存期也不必事先告诉编译器

缺点：由于是动态分配内存大小，所以存取速度慢一些

栈（Stack）：

优点：存取速度仅次与CPU的寄存器，栈中的数据是共享的

缺点：栈中的数据内存大小与生存期必须是固定的

数据存储位置 ：

基本数据类型存储在栈中，对象的引用存储在栈中，对象中的方法的本地变量存储在栈中

对象的本身存储在堆中，对象的成员变量存储在堆中，静态成员变量存储在堆中



### 7、Java内存模型 -  同步八种操作

lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态

unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎

assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量

store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作

write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中

### 8、Java内存模型 - 同步规则

1）：如果把一个变量从主内存复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型值要求上述操作必须按顺序执行，而没有保证必须是连续执行

2）：不允许read和load、store和write操作之一单独出现

3）：不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中

4）：不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中

5）：一个新的变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，即就是一个变量实施use和store操作之前，必须先执行过了assign和load操作

5）：一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现

6）：如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要执行load或assign操作初始化变量的值

7）：如果一个变量事先没有对lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量

8）：对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

![](./images/3.jpg)

### 9、并发的优势与风险

![](./images/4.jpg)